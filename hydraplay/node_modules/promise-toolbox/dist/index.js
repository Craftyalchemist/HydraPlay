'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.try = exports.attempt = exports.TimeoutError = exports.promisifyAll = exports.promisify = exports.finally = exports.fromEvents = exports.fromEvent = exports.fromCallback = exports.forOwn = exports.forIterable = exports.forIn = exports.forEach = exports.forArray = exports.makeAsyncIterator = exports.defer = exports.cancellable = exports.cancelable = exports.CancelToken = exports.Cancel = exports.nodeify = exports.wrapApply = exports.wrapCall = exports.isPromise = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.all = all;
exports.asCallback = asCallback;
exports.catchPlus = catchPlus;
exports.delay = delay;
exports.disposer = disposer;
exports.using = using;
exports.ignoreErrors = ignoreErrors;
exports.join = join;
exports.lastly = lastly;
exports.reflect = reflect;
exports.settle = settle;
exports.some = some;
exports.tap = tap;
exports.timeout = timeout;
exports.unpromisify = unpromisify;

var _makeError = require('make-error');

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// ===================================================================

if (typeof Promise !== 'function' || typeof Promise.reject !== 'function' || typeof Promise.resolve !== 'function') {
  throw new Error('a standard Promise implementation is required (https://github.com/JsCommunity/promise-toolbox#usage)');
}

// ===================================================================

var _endsWith = function _endsWith(str, suffix) {
  var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : str.length;

  pos -= suffix.length;
  return pos >= 0 && str.indexOf(suffix, pos) === pos;
};

var _isArray = Array.isArray || function (value) {
  return value instanceof Array;
};

var _isLength = function _isLength(value) {
  return typeof value === 'number' && value >= 0 && value < Infinity && Math.floor(value) === value;
};

var _isArrayLike = function _isArrayLike(value) {
  return value && typeof value !== 'function' && _isLength(value.length);
};

var _iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator || '@@iterator';

var _isIterable = function _isIterable(value) {
  return value && typeof value[_iteratorSymbol] === 'function';
};

var _once = function _once(fn) {
  var result = void 0;
  return function () {
    if (fn !== null) {
      result = fn.apply(this, arguments);
      fn = null;
    }
    return result;
  };
};

var _noop = function _noop() {};

// -------------------------------------------------------------------

var _forArray = function _forArray(array, iteratee) {
  var length = array.length;

  for (var i = 0; i < length; ++i) {
    iteratee(array[i], i, array);
  }
};

var _forIn = function _forIn(object, iteratee) {
  for (var key in object) {
    iteratee(object[key], key, object);
  }
};

var _forIterable = function _forIterable(iterable, iteratee) {
  var iterator = iterable[Symbol.iterator]();

  var current = void 0;
  while (!(current = iterator.next()).done) {
    iteratee(current.value, null, iterable);
  }
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var _forOwn = function _forOwn(object, iteratee) {
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      iteratee(object[key], key, object);
    }
  }
};

var _forEach = function _forEach(collection, iteratee) {
  return _isArray(collection) ? _forArray(collection, iteratee) : _isIterable(collection) ? _forIterable(collection, iteratee) : _isArrayLike(collection) ? _forArray(collection, iteratee) : _forOwn(collection, iteratee);
};

var _map = function _map(collection, iteratee) {
  var result = _isArrayLike(collection) ? new Array(collection.length) : {};

  // If iteratee is not a function, simply returns the new container.
  if (iteratee) {
    _forEach(collection, function (item, key) {
      result[key] = iteratee(item, key, collection);
    });
  }

  return result;
};

// ===================================================================

var isPromise = exports.isPromise = function isPromise(value) {
  return value != null && typeof value.then === 'function';
};

// -------------------------------------------------------------------

var _makeAsyncIterator = function _makeAsyncIterator(iterator) {
  return function (promises, cb) {
    var mainPromise = Promise.resolve();

    iterator(promises, function (promise, key) {
      mainPromise = isPromise(promise) ? mainPromise.then(function () {
        return promise.then(function (value) {
          return cb(value, key, promises);
        });
      }) : mainPromise.then(function () {
        return cb(promise, key, promises);
      });
    });

    return mainPromise;
  };
};

var _wrap = function _wrap(value) {
  return isPromise(value) ? value : Promise.resolve(value);
};

var wrapCall = exports.wrapCall = function wrapCall(fn, arg, thisArg) {
  try {
    return _wrap(fn.call(thisArg, arg));
  } catch (error) {
    return Promise.reject(error);
  }
};

var wrapApply = exports.wrapApply = function wrapApply(fn, args, thisArg) {
  try {
    return _wrap(fn.apply(thisArg, args));
  } catch (error) {
    return Promise.reject(error);
  }
};

// ===================================================================

var _all = function _all(promises, mapFn) {
  return new Promise(function (resolve, reject) {
    // mapFn may be undefined but it's okay :)
    var result = _map(promises, mapFn);

    var count = 1;
    var onFulfillment0 = function onFulfillment0() {
      if (--count === 0) {
        var tmp = result;
        result = null;
        resolve(tmp);
      }
    };

    var onFulfillment = function onFulfillment(value, key) {
      if (!result) {
        return;
      }

      result[key] = value;
      onFulfillment0();
    };

    var onRejection = function onRejection(reason) {
      if (!result) {
        return;
      }

      result = null;
      reject(reason);
    };

    _forEach(mapFn ? result : promises, function (promise, key) {
      ++count;

      if (isPromise(promise)) {
        promise.then(function (value) {
          return onFulfillment(value, key);
        }, onRejection);
      } else {
        onFulfillment(promise, key);
      }
    });
    onFulfillment0();
  });
};

// Returns a promise which resolves when all the promises in a
// collection have resolved or rejects with the reason of the first
// promise that rejects.
//
// Optionally a function can be provided to map all items in the
// collection before waiting for completion.
//
// Usage: promises::all([ mapFn ])
function all(mapFn) {
  return _wrap(this).then(function (promises) {
    return _all(promises, mapFn);
  });
}

// -------------------------------------------------------------------

// Usage: promise::asCallback(cb)
function asCallback(cb) {
  // cb can be undefined.
  if (cb) {
    this.then(function (value) {
      return cb(null, value);
    }, function (error) {
      return cb(error);
    }).then(null, _noop);
  }

  return this;
}

exports.nodeify = asCallback;

// -------------------------------------------------------------------

var Cancel = exports.Cancel = function () {
  function Cancel() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'this action has been canceled';

    _classCallCheck(this, Cancel);

    Object.defineProperty(this, 'message', {
      enumerable: true,
      value: message
    });
  }

  _createClass(Cancel, [{
    key: 'toString',
    value: function toString() {
      return `Cancel: ${this.message}`;
    }
  }]);

  return Cancel;
}();

var _cancelTokenTag = 'CancelToken';
var _toStringTagSymbol = typeof Symbol === 'function' && Symbol.toStringTag || '@@toStringTag';

// https://github.com/zenparsing/es-cancel-token
// https://tc39.github.io/proposal-cancelable-promises/

var CancelToken = exports.CancelToken = function () {
  _createClass(CancelToken, null, [{
    key: 'isCancelToken',
    value: function isCancelToken(value) {
      return value != null && typeof value[_toStringTagSymbol] === 'function' && value[_toStringTagSymbol]() === _cancelTokenTag;
    }

    // https://github.com/zenparsing/es-cancel-token/issues/3#issuecomment-221173214

  }, {
    key: 'source',
    value: function source() {
      var cancel = void 0;
      var token = new CancelToken(function (cancel_) {
        cancel = cancel_;
      });
      return { cancel, token };
    }
  }, {
    key: 'race',
    value: function race(tokens, _executor) {
      return new CancelToken(function (cancel) {
        _forEach(tokens, function (token) {
          var reason = token.reason;

          if (reason !== undefined) {
            cancel(reason);
            return false;
          }

          token.addHandler(cancel);
        });
        if (_executor !== undefined) {
          _executor(cancel);
        }
      });
    }
  }]);

  function CancelToken(executor) {
    var _this = this;

    _classCallCheck(this, CancelToken);

    this._handlers = null;
    this._promise = null;
    this._reason = undefined;
    this._resolve = null;

    executor(_once(function (message) {
      var reason = _this._reason = message instanceof Cancel ? message : new Cancel(message);

      var resolve = _this._resolve;
      if (resolve !== null) {
        _this._resolve = null;
        resolve(reason);
      }

      var handlers = _this._handlers;
      if (handlers !== null) {
        _this._handlers = null;

        var _defer = defer(),
            promise = _defer.promise,
            _resolve = _defer.resolve;

        var wait = 0;
        var onSettle = function onSettle() {
          if (--wait === 0) {
            return _resolve();
          }
        };
        for (var i = 0, n = handlers.length; i < n; ++i) {
          try {
            var result = handlers[i](reason);
            if (isPromise(result)) {
              ++wait;
              result.then(onSettle, onSettle);
            }
          } catch (_) {}
        }
        if (wait !== 0) {
          return promise;
        }
      }
    }));
  }

  _createClass(CancelToken, [{
    key: 'fork',
    value: function fork(executor) {
      if (executor !== undefined) {
        return CancelToken.race([this], executor);
      }

      var cancel = void 0;
      var token = CancelToken.race([this], function (c) {
        cancel = c;
      });
      return { cancel, token };
    }

    // register a handler to execute when the token is canceled
    //
    // handlers are all executed in parallel, the promise returned by
    // the `cancel` function will wait for all handlers to be settled

  }, {
    key: 'addHandler',
    value: function addHandler(handler) {
      var handlers = this._handlers;
      if (handlers === null) {
        if (this.requested) {
          throw new TypeError('cannot add a handler to an already canceled token');
        }

        handlers = this._handlers = [];
      }
      handlers.push(handler);
    }
  }, {
    key: 'throwIfRequested',
    value: function throwIfRequested() {
      var reason = this._reason;
      if (reason !== undefined) {
        throw reason;
      }
    }
  }, {
    key: _toStringTagSymbol,
    value: function value() {
      return _cancelTokenTag;
    }
  }, {
    key: 'promise',
    get: function get() {
      var _this2 = this;

      var promise = this._promise;
      if (promise === null) {
        var reason = this._reason;
        promise = this._promise = reason !== undefined ? Promise.resolve(reason) : new Promise(function (resolve) {
          _this2._resolve = resolve;
        });
      }
      return promise;
    }
  }, {
    key: 'reason',
    get: function get() {
      return this._reason;
    }
  }, {
    key: 'requested',
    get: function get() {
      return this._reason !== undefined;
    }
  }]);

  return CancelToken;
}();

// Usage:
//
//     @cancelable
//     async fn (cancelToken, other, args) {
//       if (!cancelToken.requested) {
//         doStuff()
//       }
//
//       cancelToken.throwIfRequested()
//
//       doSomeMoreStuff()
//
//       cancelToken.promise.then(() => {
//         // Do stuff if canceled.
//       })
//
//       // do other stuff.
//     }


var cancelable = exports.cancelable = function cancelable(target, name, descriptor) {
  var fn = descriptor !== undefined ? descriptor.value : target;

  function cancelableWrapper() {
    var length = arguments.length;

    if (length !== 0 && CancelToken.isCancelToken(arguments[0])) {
      return fn.apply(this, arguments);
    }

    var _CancelToken$source = CancelToken.source(),
        cancel = _CancelToken$source.cancel,
        token = _CancelToken$source.token;

    var args = new Array(length + 1);
    args[0] = token;
    for (var i = 0; i < length; ++i) {
      args[i + 1] = arguments[i];
    }

    var promise = fn.apply(this, args);
    promise.cancel = cancel;

    return promise;
  }

  if (descriptor !== undefined) {
    descriptor.value = cancelableWrapper;
    return descriptor;
  }

  return cancelableWrapper;
};
exports.cancellable = cancelable; // alternative UK spelling

// -------------------------------------------------------------------

var _isProgrammerError = function _isProgrammerError(reason) {
  return reason instanceof ReferenceError || reason instanceof SyntaxError || reason instanceof TypeError;
};

var _matchError = function _matchError(predicate, error) {
  if (typeof predicate === 'function') {
    return predicate === Error || predicate.prototype instanceof Error ? error instanceof predicate : predicate(error);
  }

  if (error != null && typeof predicate === 'object') {
    for (var key in predicate) {
      if (hasOwnProperty.call(predicate, key) && error[key] !== predicate[key]) {
        return false;
      }
    }
    return true;
  }
};

// Similar to `Promise#catch()` but:
// - support predicates
// - do not catch `ReferenceError`, `SyntaxError` or `TypeError`
//   unless they match a predicate because they are usually programmer
//   errors and should be handled separately.
function catchPlus() {
  var _this3 = this;

  var n = arguments.length - 1;

  var cb = void 0;
  if (n < 0 || typeof (cb = arguments[n]) !== 'function') {
    return this;
  }

  var predicates = void 0;
  if (n !== 0) {
    predicates = new Array(n);
    for (var i = 0; i < n; ++i) {
      predicates[i] = arguments[i];
    }
  }

  return _wrap(this).then(null, function (reason) {
    if (predicates !== undefined) {
      for (var _i = 0; _i < n; ++_i) {
        if (_matchError(predicates[_i], reason)) {
          return cb(reason);
        }
      }
    } else if (!_isProgrammerError(reason)) {
      return cb(reason);
    }

    // Forward error without throwing (perf).
    return _this3;
  });
}

// -------------------------------------------------------------------

// Discouraged but sometimes necessary way to create a promise.
var defer = exports.defer = function defer() {
  var resolve = void 0,
      reject = void 0;
  var promise = new Promise(function (resolve_, reject_) {
    // eslint-disable-line promise/param-names
    resolve = resolve_;
    reject = reject_;
  });

  return {
    promise,
    reject,
    resolve
  };
};

// -------------------------------------------------------------------

// Usage: promise::delay(ms)
function delay(ms) {
  var _this4 = this;

  return isPromise(this) ? this.then(function (value) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        return resolve(value);
      }, ms);
    });
  }) : new Promise(function (resolve) {
    setTimeout(function () {
      return resolve(_this4);
    }, ms);
  });
}

// -------------------------------------------------------------------

function Resource(promise, disposer) {
  this.d = disposer;
  this.p = promise;
}

// Usage: promise::disposer(disposer)
function disposer(disposer) {
  return new Resource(this, disposer);
}

// Usage: using(disposers…, handler)
function using() {
  var _this5 = this;

  var nResources = arguments.length - 1;

  if (nResources < 1) {
    throw new TypeError('using expects at least 2 arguments');
  }

  var handler = arguments[nResources];

  var resources = arguments[0];
  var spread = nResources > 1 || !_isArray(resources);
  if (spread) {
    resources = new Array(nResources);
    for (var i = 0; i < nResources; ++i) {
      resources[i] = arguments[i];
    }
  } else {
    nResources = resources.length;
  }

  var dispose = _once(function (fn, value) {
    var leftToProcess = nResources;

    var onSettle = function onSettle() {
      if (--leftToProcess === 0) {
        fn(value);
      }
    };

    // like Bluebird, on failure to dispose a resource, throw an async error
    var onFailure = function onFailure(reason) {
      setTimeout(function () {
        throw reason;
      }, 0);
    };

    _forArray(resources, function (resource) {
      var d = void 0;
      if (resource != null && typeof (d = resource.d) === 'function') {
        resource.p.then(function (value) {
          return wrapCall(d, value).then(onSettle, onFailure);
        }, onSettle);

        resource.p = resource.d = null;
      } else {
        --leftToProcess;
      }
    });
  });

  return new Promise(function (resolve, reject) {
    var values = new Array(nResources);
    var leftToProcess = nResources;

    var _onProviderFailure_ = function onProviderFailure_(reason) {
      _onProviderFailure_ = onProviderSettle;
      onSettle = function onSettle() {
        return dispose(reject, reason);
      };

      onProviderSettle();
    };
    var onProviderFailure = function onProviderFailure(reason) {
      return _onProviderFailure_(reason);
    };

    var onProviderSettle = function onProviderSettle() {
      if (--leftToProcess === 0) {
        onSettle();
      }
    };

    var onSettle = function onSettle() {
      return (spread ? wrapApply : wrapCall)(handler, values, _this5).then(function (value) {
        return dispose(resolve, value);
      }, function (reason) {
        return dispose(reject, reason);
      });
    };

    _forArray(resources, function (resource, i) {
      var p = resource instanceof Resource ? resource.p : resource;
      if (p === null) {
        onProviderFailure(new TypeError('resource has already been disposed of'));
        return;
      }

      p.then(function (value) {
        values[i] = value;

        onProviderSettle();
      }, onProviderFailure);
    });
  });
}

// -------------------------------------------------------------------

var makeAsyncIterator = exports.makeAsyncIterator = function makeAsyncIterator(iterator) {
  var asyncIterator = _makeAsyncIterator(iterator);

  return function (cb) {
    return _wrap(this).then(function (promises) {
      return asyncIterator(promises, cb);
    }).then(_noop); // Resolves to undefined
  };
};

var forArray = exports.forArray = makeAsyncIterator(_forArray);
var forEach = exports.forEach = makeAsyncIterator(_forEach);
var forIn = exports.forIn = makeAsyncIterator(_forIn);
var forIterable = exports.forIterable = makeAsyncIterator(_forIterable);
var forOwn = exports.forOwn = makeAsyncIterator(_forOwn);

// -------------------------------------------------------------------

// Usage:
//
//     fromCallback(cb => fs.readFile('foo.txt', cb))
//       .then(content => {
//         console.log(content)
//       })
var fromCallback = exports.fromCallback = function fromCallback(fn) {
  return new Promise(function (resolve, reject) {
    fn(function (error, result) {
      return error ? reject(error) : resolve(result);
    });
  });
};

// -------------------------------------------------------------------

var _ignoreErrorsCb = function _ignoreErrorsCb(error) {
  if (_isProgrammerError(error)) {
    throw error;
  }
};

function ignoreErrors() {
  if (!isPromise(this)) {
    return this;
  }

  return this.then(null, _ignoreErrorsCb);
}

// -------------------------------------------------------------------

var _makeEventAdder = function _makeEventAdder($cancelToken, emitter, arrayArg) {
  var add = emitter.addEventListener || emitter.addListener || emitter.on;
  if (add === undefined) {
    throw new Error('cannot register event listener');
  }

  var remove = emitter.removeEventListener || emitter.removeListener || emitter.off;

  var eventsAndListeners = [];

  var clean = _noop;
  if (remove !== undefined) {
    clean = _once(function () {
      for (var i = 0, n = eventsAndListeners.length; i < n; i += 2) {
        remove.call(emitter, eventsAndListeners[i], eventsAndListeners[i + 1]);
      }
    });
    $cancelToken.promise.then(clean);
  }

  return arrayArg ? function (event, cb) {
    function listener() {
      clean();
      var length = arguments.length;

      var args = new Array(length);
      for (var i = 0; i < length; ++i) {
        args[i] = arguments[i];
      }
      args.event = event;
      cb(args);
    }
    eventsAndListeners.push(event, listener);
    add.call(emitter, event, listener);
  } : function (event, cb) {
    var listener = function listener(arg) {
      clean();
      cb(arg);
    };
    eventsAndListeners.push(event, listener);
    add.call(emitter, event, listener);
  };
};

var fromEvent = exports.fromEvent = cancelable(function ($cancelToken, emitter, event) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return new Promise(function (resolve, reject) {
    var add = _makeEventAdder($cancelToken, emitter, opts.array);
    add(event, resolve);
    if (!opts.ignoreErrors) {
      var _opts$error = opts.error,
          error = _opts$error === undefined ? 'error' : _opts$error;

      if (error !== event) {
        add(error, reject);
      }
    }
  });
});

var fromEvents = exports.fromEvents = cancelable(function ($cancelToken, emitter, successEvents) {
  var errorEvents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ['error'];
  return new Promise(function (resolve, reject) {
    var add = _makeEventAdder($cancelToken, emitter, true);
    _forArray(successEvents, function (event) {
      return add(event, resolve);
    });
    _forArray(errorEvents, function (event) {
      return add(event, reject);
    });
  });
});

// -------------------------------------------------------------------

// Usage: join(p1, ..., pn, cb) or join([p1, ..., pn], cb)
function join() {
  var n = arguments.length - 1;
  var cb = arguments[n];

  var promises = void 0;
  if (n === 0) {
    return new Promise(function (resolve) {
      return resolve(cb());
    });
  } else if (n !== 1) {
    promises = new Array(n);
    for (var i = 0; i < n; ++i) {
      promises[i] = arguments[i];
    }
  } else if (!_isArrayLike(promises = arguments[0])) {
    return _wrap(promises).then(function (value) {
      return cb(value);
    });
  }

  return _all(promises).then(function (args) {
    return cb.apply(null, args);
  });
}

// -------------------------------------------------------------------

// Ponyfill for Promise.finally(cb)
//
// Usage: promise::lastly(cb)
function lastly(cb) {
  var _this6 = this;

  return _wrap(this).then(function (value) {
    return _wrap(cb()).then(function () {
      return _this6;
    });
  }, function (reason) {
    return _wrap(cb()).then(function () {
      return _this6;
    });
  });
}
exports.finally = lastly;

// -------------------------------------------------------------------

var _setFunctionNameAndLength = function () {
  var _defineProperties = Object.defineProperties;

  try {
    var f = _defineProperties(function () {}, {
      length: { value: 2 },
      name: { value: 'foo' }
    });

    if (f.length === 2 && f.name === 'foo') {
      return function (fn, name, length) {
        return _defineProperties(fn, {
          length: {
            configurable: true,
            value: length
          },
          name: {
            configurable: true,
            value: name
          }
        });
      };
    }
  } catch (_) {}

  return function (fn) {
    return fn;
  };
}();

// Usage: promisify(fn, [ context ])
var promisify = exports.promisify = function promisify(fn, context) {
  return _setFunctionNameAndLength(function () {
    var _this7 = this;

    var length = arguments.length;

    var args = new Array(length + 1);
    for (var i = 0; i < length; ++i) {
      args[i] = arguments[i];
    }

    return new Promise(function (resolve, reject) {
      args[length] = function (error, result) {
        return error ? reject(error) : resolve(result);
      };

      fn.apply(context || _this7, args);
    });
  }, fn.name, fn.length && fn.length - 1);
};

var _DEFAULT_PALL_MAPPER = function _DEFAULT_PALL_MAPPER(name) {
  return !(_endsWith(name, 'Sync') || _endsWith(name, 'Async')) && name;
};

// Usage: promisifyAll(obj, [ opts ])
var promisifyAll = exports.promisifyAll = function promisifyAll(obj) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$mapper = _ref.mapper,
      mapper = _ref$mapper === undefined ? _DEFAULT_PALL_MAPPER : _ref$mapper,
      _ref$target = _ref.target,
      target = _ref$target === undefined ? {} : _ref$target,
      _ref$context = _ref.context,
      context = _ref$context === undefined ? obj : _ref$context;

  _forIn(obj, function (value, name) {
    var newName = void 0;
    if (typeof value === 'function' && (newName = mapper(name, value, obj))) {
      target[newName] = promisify(value, context);
    }
  });

  return target;
};

// -------------------------------------------------------------------

var FN_FALSE = function FN_FALSE() {
  return false;
};
var FN_TRUE = function FN_TRUE() {
  return true;
};

var _reflectResolution = function (__proto__) {
  return function (_value) {
    return {
      __proto__: __proto__,
      value: function value() {
        return _value;
      }
    };
  };
}({
  isFulfilled: FN_TRUE,
  isPending: FN_FALSE,
  isRejected: FN_FALSE,
  isResolved: FN_TRUE,
  reason: function reason() {
    throw new Error('no reason, the promise has resolved');
  }
});

var _reflectRejection = function (__proto__) {
  return function (_reason) {
    return {
      __proto__: __proto__,
      reason: function reason() {
        return _reason;
      }
    };
  };
}({
  isFulfilled: FN_FALSE,
  isPending: FN_FALSE,
  isRejected: FN_TRUE,
  isResolved: FN_FALSE,
  value: function value() {
    throw new Error('no value, the promise has rejected');
  }
});

// Returns a promise that is always successful when this promise is
// settled. Its fulfillment value is an object that implements the
// PromiseInspection interface and reflects the resolution this
// promise.
//
// Usage: promise::reflect()
function reflect() {
  return _wrap(this).then(_reflectResolution, _reflectRejection);
}

// -------------------------------------------------------------------

// Given a collection (array or object) which contains promises,
// return a promise that is fulfilled when all the items in the
// collection are either fulfilled or rejected.
//
// This promise will be fulfilled with a collection (of the same type,
// array or object) containing promise inspections.
//
// Usage: promises::settle()
function settle() {
  return all.call(this, function (x) {
    return reflect.call(x);
  });
}

// -------------------------------------------------------------------

var _some = function _some(promises, count) {
  return new Promise(function (resolve, reject) {
    var values = [];
    var errors = [];

    var onFulfillment = function onFulfillment(value) {
      if (!values) {
        return;
      }

      values.push(value);
      if (--count === 0) {
        resolve(values);
        values = errors = null;
      }
    };

    var acceptableErrors = -count;
    var onRejection = function onRejection(reason) {
      if (!values) {
        return;
      }

      errors.push(reason);
      if (--acceptableErrors === 0) {
        reject(errors);
        values = errors = null;
      }
    };

    _forEach(promises, function (promise) {
      ++acceptableErrors;
      _wrap(promise).then(onFulfillment, onRejection);
    });
  });
};

// Usage: promises::some(count)
function some(count) {
  return _wrap(this).then(function (promises) {
    return _some(promises, count);
  });
}

// -------------------------------------------------------------------

function tap(onResolved, onRejected) {
  var _this8 = this;

  var forward = function forward() {
    return _this8;
  };

  return _wrap(this).then(onResolved && function (value) {
    return _wrap(onResolved(value)).then(forward);
  }, onRejected && function (reason) {
    return _wrap(onRejected(reason)).then(forward);
  });
}

// -------------------------------------------------------------------

var TimeoutError = exports.TimeoutError = function (_BaseError) {
  _inherits(TimeoutError, _BaseError);

  function TimeoutError() {
    _classCallCheck(this, TimeoutError);

    return _possibleConstructorReturn(this, (TimeoutError.__proto__ || Object.getPrototypeOf(TimeoutError)).call(this, 'operation timed out'));
  }

  return TimeoutError;
}(_makeError.BaseError);

// Usage: promise::timeout(ms, cb)


function timeout(ms, cb) {
  var _this10 = this;

  return new Promise(function (resolve, reject) {
    var handle = setTimeout(function () {
      handle = null;

      if (typeof _this10.cancel === 'function') {
        _this10.cancel();
      }

      if (cb) {
        try {
          resolve(cb());
        } catch (error) {
          reject(error);
        }
      } else {
        reject(new TimeoutError());
      }
    }, ms);

    _wrap(_this10).then(function (value) {
      handle !== null && clearTimeout(handle);
      resolve(value);
    }, function (reason) {
      handle !== null && clearTimeout(handle);
      reject(reason);
    });
  });
}

// -------------------------------------------------------------------

var attempt = exports.attempt = function attempt(fn) {
  return new Promise(function (resolve) {
    return resolve(fn());
  });
};
exports.try = attempt;

// -------------------------------------------------------------------

// Usage: fn::unpromisify()

function unpromisify() {
  var fn = this;
  return _setFunctionNameAndLength(function () {
    var n = arguments.length - 1;
    var cb = void 0;
    if (n < 0 || typeof (cb = arguments[n]) !== 'function') {
      throw new Error('missing callback');
    }

    var args = new Array(n);
    for (var i = 0; i < n; ++i) {
      args[i] = arguments[i];
    }

    wrapApply(fn, args, this).then(function (result) {
      return cb(null, result);
    }, function (reason) {
      return cb(reason);
    });
  }, fn.name, fn.length + 1);
}
//# sourceMappingURL=index.js.map