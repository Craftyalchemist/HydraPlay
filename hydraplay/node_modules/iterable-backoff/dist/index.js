'use strict';

exports.__esModule = true;
const symbolIterator = exports.symbolIterator = typeof Symbol !== 'undefined' && Symbol.iterator || '@@iterator';

const DONE = { done: true };

class Iterator {

  constructor(next) {
    this.next = next;
  }

  // $FlowFixMe https://github.com/facebook/flow/issues/2286
  [symbolIterator]() {
    return this;
  }

  // add a percentage of noise
  addNoise(factor = 0.1) {
    return this.map(value => value * (1 + (Math.random() - 0.5) * factor));
  }

  clamp(min, max) {
    return this.map(value => value < min ? min : value > max ? max : value);
  }

  map(fn) {
    return new Iterator(() => {
      const cursor = this.next();
      if (cursor.done) {
        return cursor;
      }
      return {
        done: false,
        value: fn(cursor.value)
      };
    });
  }

  take(n) {
    let i = 0;
    return new Iterator(() => {
      if (i < n) {
        ++i;
        return this.next();
      }
      return DONE;
    });
  }

  // converts to miliseconds (ie * 1e3)
  toMs() {
    return this.map(x => Math.floor(x * 1e3));
  }
}

const exponential = exports.exponential = (base = 2) => {
  let curr = base;

  return new Iterator(() => {
    const value = curr;
    curr *= base;
    return {
      done: false,
      value
    };
  });
};

const fibonacci = exports.fibonacci = () => {
  let curr = 1;
  let next = 1;

  return new Iterator(() => {
    const value = curr;
    curr = next;
    next += value;

    return {
      done: false,
      value
    };
  });
};

const power = exports.power = (power = 2) => {
  let i = 1;

  return new Iterator(() => {
    return {
      done: false,
      value: Math.pow(i++, power)
    };
  });
};
//# sourceMappingURL=index.js.map