{"version":3,"sources":["../src/index.js"],"names":["makeAsync","fn","Promise","resolve","apply","arguments","parseMessage","message","error","format","defaultOnMessage","type","MethodNotFound","method","noop","nextRequestId","Peer","onMessage","_asyncEmitError","process","nextTick","bind","emit","_handle","_deferreds","Object","create","_getDeferred","id","deferred","exec","data","results","all","then","result","undefined","push","reject","JsonRpcError","code","catch","response","failPendingRequests","reason","deferreds","request","params","requestId","notify","notification","end","encoding","cb","write","pipe","writable","listeners","clean","listener","event","removeListener","on","n","length","String","EventEmitter"],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\nimport {\n  forEach,\n  isArray,\n  map,\n} from 'lodash'\nimport {\n  format,\n  JsonRpcError,\n  MethodNotFound,\n  parse,\n} from 'json-rpc-protocol'\n\n// ===================================================================\n\n// Give access to low level interface.\nexport * from 'json-rpc-protocol'\n\n// ===================================================================\n\nfunction makeAsync (fn) {\n  return function () {\n    return new Promise(resolve => resolve(fn.apply(this, arguments)))\n  }\n}\n\nconst parseMessage = message => {\n  try {\n    return parse(message)\n  } catch (error) {\n    throw format.error(null, error)\n  }\n}\n\n// Default onMessage implementation:\n//\n// - ignores notifications\n// - throw MethodNotFound for all requests\nfunction defaultOnMessage (message) {\n  if (message.type === 'request') {\n    throw new MethodNotFound(message.method)\n  }\n}\n\nfunction noop () {}\n\n// Starts the autoincrement id with the JavaScript minimal safe integer to have\n// more room before running out of integers (it's very far fetched but a very\n// long running process with a LOT of messages could run out).\nlet nextRequestId = -9007199254740991\n\n// ===================================================================\n\nexport default class Peer extends EventEmitter {\n  constructor (onMessage = defaultOnMessage) {\n    super()\n\n    this._asyncEmitError = process.nextTick.bind(process, this.emit.bind(this), 'error')\n    this._handle = makeAsync(onMessage)\n    this._deferreds = Object.create(null)\n  }\n\n  _getDeferred (id) {\n    const deferred = this._deferreds[id]\n    delete this._deferreds[id]\n    return deferred\n  }\n\n  async exec (message, data) {\n    message = parseMessage(message)\n\n    if (isArray(message)) {\n      const results = []\n\n      // Only returns non empty results.\n      await Promise.all(map(message, message => {\n        return this.exec(message, data).then(result => {\n          if (result !== undefined) {\n            results.push(result)\n          }\n        })\n      }))\n\n      return results\n    }\n\n    const {type} = message\n\n    if (type === 'error') {\n      const {id} = message\n\n      // Some errors do not have an identifier, simply discard them.\n      if (id === null) {\n        return\n      }\n\n      const {error} = message\n      this._getDeferred(id).reject(\n        // TODO: it would be great if we could return an error with of\n        // a more specific type (and custom types with registration).\n        new JsonRpcError(error.message, error.code, error.data)\n      )\n    } else if (type === 'response') {\n      this._getDeferred(message.id).resolve(message.result)\n    } else if (type === 'notification') {\n      this._handle(message, data).catch(noop)\n    } else {\n      return this._handle(message, data).then(\n        (result) => format.response(message.id, result === undefined ? null : result),\n        (error) => format.error(\n          message.id,\n\n          // If the method name is not defined, default to the method passed\n          // in the request.\n          (error instanceof MethodNotFound && !error.data)\n            ? new MethodNotFound(message.method)\n            : error\n        )\n      )\n    }\n  }\n\n  // Fails all pending requests.\n  failPendingRequests (reason) {\n    const {_deferreds: deferreds} = this\n\n    forEach(deferreds, ({reject}, id) => {\n      reject(reason)\n      delete deferreds[id]\n    })\n  }\n\n  /**\n   * This function should be called to send a request to the other end.\n   *\n   * TODO: handle multi-requests.\n   */\n  request (method, params) {\n    return new Promise((resolve, reject) => {\n      const requestId = nextRequestId++\n\n      this.push(format.request(requestId, method, params))\n\n      this._deferreds[requestId] = {resolve, reject}\n    })\n  }\n\n  /**\n   * This function should be called to send a notification to the other end.\n   *\n   * TODO: handle multi-notifications.\n   */\n  async notify (method, params) {\n    this.push(format.notification(method, params))\n  }\n\n  // minimal stream interface\n\n  end (data, encoding, cb) {\n    if (typeof data === 'function') {\n      process.nextTick(data)\n    } else {\n      if (typeof encoding === 'function') {\n        process.nextTick(encoding)\n      } else if (typeof cb === 'function') {\n        process.nextTick(cb)\n      }\n\n      if (data !== undefined) {\n        this.write(data)\n      }\n    }\n  }\n\n  pipe (writable) {\n    const listeners = {\n      data: data => writable.write(data),\n      end: () => {\n        writable.end()\n        clean()\n      },\n    }\n\n    const clean = () => forEach(listeners, (listener, event) => {\n      this.removeListener(event, listener)\n    })\n    forEach(listeners, (listener, event) => {\n      this.on(event, listener)\n    })\n\n    return writable\n  }\n\n  push (data) {\n    return data === null\n      ? this.emit('end')\n      : this.emit('data', data)\n  }\n\n  write (message) {\n    let cb\n    const n = arguments.length\n    if (n > 1 && typeof (cb = arguments[n - 1]) === 'function') {\n      process.nextTick(cb)\n    }\n\n    this.exec(String(message)).then(\n      response => {\n        if (response !== undefined) {\n          this.push(response)\n        }\n      },\n      this._asyncEmitError\n    )\n\n    // indicates that other calls to `write` are allowed\n    return true\n  }\n}\n"],"file":"index.js"}